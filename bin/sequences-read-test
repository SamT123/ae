#! /usr/bin/env python3
"""
Test reading ncbi files
"""

import os, sys, re, pprint, argparse, traceback
from pathlib import Path
if os.environ.get("DYLD_INSERT_LIBRARIES"):
    sys.path[:0] = [str(Path(os.environ["AE_ROOT"], dir)) for dir in ["build.debug", "py"]]
else:
    sys.path[:0] = [str(Path(os.environ["AE_ROOT"], dir)) for dir in ["build", "py"]]
from ae.sequences.source import fasta, ncbi
import ae_backend

# ----------------------------------------------------------------------

def main(args: list):
    num_seqs = 0
    messages = []
    unrecognized_locations = set()

    for filename in args.filename:
        if filename.is_dir() and filename.joinpath("influenza_na.dat.xz").exists():
            reader = ncbi.reader(filename)
        elif filename.is_file():
            reader = fasta.reader(filename)
        else:
            raise RuntimeError(f"\"{filename}\": unrecognized or does not exist")

        for metadata, sequence in reader:
            if not (excluded := metadata.get("excluded")):
                fasta.add_metadata_to_sequence(metadata, sequence)
                sequence_messages = ae_backend.Messages()
                try:
                    ae_backend.raw_sequence.translate(sequence, sequence_messages)
                    ae_backend.raw_sequence.align(sequence, sequence_messages)
                except Exception as err:
                    print(f"> {err}: {sequence.name}\n    {sequence.aa}")
                reader.context.messages_from_backend(sequence_messages)
                if sequence.is_translated_not_aligned() and args.report_not_aligned and re.match(r"(A\(H[13]N|B)", sequence.type_subtype):
                    print(f">> not aligned {sequence.name} ({sequence.type_subtype})\n{sequence.aa}")
            elif args.print_messages and args.report_excluded:
                print(f">> excluded: {metadata}")
            messages += reader.get_and_clear_messages()
            num_seqs += 1
        unrecognized_locations |= reader.unrecognized_locations

    print(f">>> {num_seqs} sequences read")

    # print(f"Labs: {len(labs)}\n{pprint.pformat(labs)}")
    print(f"Messages: {len(messages)}")
    if args.print_messages and messages:
        message_types = args.print_messages.lower()
        for msg in messages:
            if msg.type_matches(message_types):
                print(f"  {msg.report()}")
        if unrecognized_locations and "l" in message_types or "a" in message_types:
            print(f"Unrecognized locations: {len(unrecognized_locations)}")
            for loc in unrecognized_locations:
                print(f"  {loc}")

# ----------------------------------------------------------------------

try:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("filename", nargs="+", type=Path)
    parser.add_argument("-m", dest="print_messages", default=None, help="report messages by type: a - all, l - unrecognized locations, d - deletion issues, s - subtype issues, v - lineage issues, y - date issues")
    parser.add_argument("--report-not-aligned", dest="report_not_aligned", action='store_true', default=False)
    parser.add_argument("--report-excluded", dest="report_excluded", action='store_true', default=False)
    args = parser.parse_args()
    exit_code = main(args) or 0
except Exception as err:
    print(f"> {err}\n{traceback.format_exc()}", file=sys.stderr)
    exit_code = 1
exit(exit_code)
