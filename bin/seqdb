#! /usr/bin/env python3
"""
Seqdb lookup
"""

import os, sys, argparse, traceback
from pathlib import Path
# if os.environ.get("DYLD_INSERT_LIBRARIES"):
#     sys.path[:0] = [str(Path(os.environ["AE_ROOT"], dir)) for dir in ["build.debug", "py"]]
# else:
#     sys.path[:0] = [str(Path(os.environ["AE_ROOT"], dir)) for dir in ["build", "py"]]
from ae.sequences.source import fasta
import ae_backend

# ----------------------------------------------------------------------

sSubtypeFix = {"B": "B", "BVIC": "B", "BV": "B", "BY": "B", "BYAM": "B", "A(H1N1)": "A(H1N1)", "H1": "A(H1N1)", "1": "A(H1N1)", "A(H3N2)": "A(H3N2)", "H3": "A(H3N2)", "3": "A(H3N2)"}

def main(args: argparse.Namespace):
    subtype = args.name and sSubtypeFix.get(args.name[0].upper())
    if subtype and subtype[0] == "B" and len(subtype) > 1:
        lineage = subtype[1]
    else:
        lineage = None
    if subtype:
        find(subtype, lineage=lineage, names=args.name[1:], args=args)
    else:
        for subtype in ["B", "A(H1N1)", "A(H3N2)"]:
            find(subtype, lineage=None, names=args.name, args=args)

# ----------------------------------------------------------------------

def find(subtype: str, lineage: str, names: list[str], args: argparse.Namespace):
    selected = ae_backend.seqdb.for_subtype(subtype).select_all()
    selected.exclude_with_issue(not args.with_issues)
    if lineage:
        subtype.lineage(lineage)
    selected.filter_dates(args.start_date, args.end_date)

    reporting = args.aa or args.country or args.continent or names
    if not reporting:
        selected.remove_hash_duplicates().replace_with_master()
    else:
        selected.find_masters()

    if names:
        selected.filter_name([name.upper() for name in names])
    if args.country:
        args.country = args.country.upper()
        if args.country == "USA":
            args.country = "UNITED STATES OF AMERICA"
        selected.filter(lambda ref: ref.country() == args.country)
    if args.continent:
        selected.filter(lambda ref: ref.continent() == args.continent)
    if args.aa:
        selected.filter(lambda ref: ref.aa[args.aa])
    selected.sort(args.sort_order)
    if not args.any_host:
        if args.host and (host := args.host.upper()) != "HUMAN":
            selected.filter_host(host)
        else:
            selected.human()

    print_names = True
    max_names = 20 if not reporting else 0

    if args.fasta_aa:
        fasta.write(args.fasta_aa, selected, aa=True, wrap_pos=80 if args.wrap else 0, name=lambda ref: ref.seq_id())
        print_names = len(selected) < 20
    if args.fasta_nuc:
        fasta.write(args.fasta_nuc, selected, aa=False, wrap_pos=80 if args.wrap else 0, name=lambda ref: ref.seq_id())
        print_names = len(selected) < 20
    if not reporting:
        print(f">>> {subtype:7s} {len(selected)}", file=sys.stderr)
    if print_names:
        if clades_file := os.environ.get("AC_CLADES_JSON_V2"):
            selected.find_clades(clades_file)

        if args.format:
            def output(seq):

                class FormatMap (dict):

                    def __missing__(self, key):
                        if key in ["seq_id", "seq-id", "seqid"]:
                            return seq.seq_id()
                        elif key == "name":
                            return seq.name()
                        elif key == "date":
                            return seq.date()
                        elif key == "clades":
                            if seq.clades:
                                return " ".join(seq.clades)
                            else:
                                return ""
                        elif key == "country":
                            return seq.country()
                        elif key == "continent":
                            return seq.continent()
                        elif key == "issues":
                            return seq.issues()
                        elif key == "aa":
                            return seq.aa
                        elif key[:3] == "aa-":
                            try:
                                return seq.aa[int(key[3:])]
                            except:
                                return f"{{{key}}}"
                        elif key[:4] == "laa-":
                            try:
                                return f"{key[4:]}{seq.aa[int(key[4:])]}"
                            except:
                                return f"{{{key}}}"
                        elif key == "nuc":
                            return seq.nuc
                        elif key[:4] == "nuc-":
                            try:
                                return seq.nuc[int(key[4:])]
                            except:
                                return f"{{{key}}}"
                        elif key[:5] == "lnuc-":
                            try:
                                return f"{key[5:]}{seq.nuc[int(key[5:])]}"
                            except:
                                return f"{{{key}}}"
                        else:
                            return f"{{{key}}}"

                return args.format.format_map(FormatMap())
        else:
            def output(seq):
                if clades := seq.clades:
                    display_clades = " (\"" + '" "'.join(clades) + "\")"
                else:
                    display_clades = ""
                issues = f" issues:{seq.issues()}" if seq.has_issues() else ""
                return f"{seq.seq_id()} [{seq.date()}]{display_clades}{issues}"

        for no, seq in enumerate(selected):
            print(output(seq))
            if max_names and no >= max_names:
                break

# ----------------------------------------------------------------------

# def write_fasta(selected :ae_backend.seqdb.Selected, filename: Path, aa: bool, wrap: bool):
#     def do_wrap(data: str):
#         if wrap:
#             size = 80
#             return "\n".join(data[i:i+size] for i in range(0, len(data), size))
#         else:
#             return data

#     if filename == "-":
#         fil = sys.stdout
#     else:
#         fil = filename.open("w")
#     for ref in selected:
#         fil.write(f">{ref.seq_id()}\n{do_wrap(ref.aa() if aa else ref.nuc())}\n")
#     if filename != "-":
#         fil.close()

# ----------------------------------------------------------------------

try:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-b", "--start-date", dest="start_date", default="")
    parser.add_argument("-e", "--end-date", dest="end_date", default="")
    parser.add_argument("--with-issues", dest="with_issues", action="store_true", default=False)
    parser.add_argument("-s", "--sort", dest="sort_order", default="+date", help="date, +date, -date, name, +name, -name")
    parser.add_argument("--fas-aa", dest="fasta_aa", type=Path)
    parser.add_argument("--fas-nuc", dest="fasta_nuc", type=Path)
    parser.add_argument("--wrap", dest="wrap", action="store_true", default=False)
    parser.add_argument("--any-host", dest="any_host", action="store_true", default=False)
    parser.add_argument("--host", dest="host")
    parser.add_argument("--country")
    parser.add_argument("--continent")
    parser.add_argument("--aa")
    parser.add_argument("-f", "--format", help="output format: {seq_id} {date} {aa} {aa-163} {laa-163} {nuc} {nuc-163} {lnuc-163} {clades} {name} {country} {continent} {issues}")
    parser.add_argument("name", nargs="*")
    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true", default=False)
    args = parser.parse_args()
    exit_code = main(args) or 0
except Exception as err:
    print(f"> {err}\n{traceback.format_exc()}", file=sys.stderr)
    exit_code = 1
exit(exit_code)

# ======================================================================
