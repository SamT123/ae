#! /usr/bin/env python3
"""
Seqdb compare sequences
"""

import os, sys, collections, json, pprint, argparse, traceback
from pathlib import Path
import ae_backend

# ----------------------------------------------------------------------

sAllSubtypes = ["B", "A(H1N1)", "A(H3N2)"]

# ----------------------------------------------------------------------

class Group:

    class Seq:

        def __init__(self, seq, nuc: bool):
            self.seq_id = seq.seq_id()
            self.seq = getattr(seq, "nuc" if nuc else "aa")

    def __init__(self, name: str, seqs: list, nuc: bool):
        self.name = name
        self.seqs = [self.Seq(seq=seq, nuc=nuc) for seq in seqs]
        self.longest = max(len(seq.seq) for seq in self.seqs)
        self.counters = [collections.Counter(seq.seq[pos] for seq in self.seqs if len(seq.seq) >= pos) for pos in range(1, self.longest + 1)]

    def most_frequent(self, positions: list):
        return {pos: self.counters[pos].most_common(1)[0] for pos in positions}

    def make_summary(self, positions: list, most_frequent: dict, threshold: float):
        num_rows = max(len(cnt) for cnt in self.counters)
        rows = []
        for row_no in range(num_rows):
            name = self.name if row_no == 0 else ""
            if row_no == 0 and most_frequent:
                def format_pos(source, pos):
                    return "." if source == most_frequent[pos][0] else source
                rows.append([name] + [format_pos(self.counters[pos].most_common()[row_no][0], pos=pos) for pos in positions])
            else:
                def format_pos(source):
                    if row_no < len(source):
                        return source[row_no][0]
                    else:
                        return " "
                rows.append([name] + [format_pos(self.counters[pos].most_common()) for pos in positions])
        return rows

    def __repr__(self):
        return f"{self.name}:{{seqs: {len(self.seqs)} }}"

    def format_json(self, positions: list):
        return {
            "name": self.name,
            "pos1": {str(pos0+1): [{"a": aa, "c": count} for aa, count in self.counters[pos0].most_common()] for pos0 in positions},
            "seq": [{"id": seq.seq_id, "seq": str(seq.seq)} for seq in self.seqs]
        }

# ----------------------------------------------------------------------

class Groups:

    def __init__(self, sources: dict, nuc: bool):
        self.subtype = sources.get("subtype")
        self.lineage = sources.get("lineage")
        self.groups = [Group(name=group, seqs=[s2 for s1 in (self.name_to_seq(name, sources) for name in names) for s2 in s1], nuc=nuc) for group, names in sources["groups"].items()]

    def name_to_seq(self, name: str, sources: dict):

        def find(subtype: str):
            look_for = name[len(subtype) + 1:] if name.startswith(f"{subtype}/") else name
            selected = ae_backend.seqdb.for_subtype(subtype).select_all()
            selected.exclude_with_issue()
            selected.filter_name([look_for.upper()])
            selected.find_masters()
            if selected:
                return list(selected)
            else:
                return None

        subtypes = [sources["subtype"]] if sources.get("subtype") else sAllSubtypes
        data = None
        for subtype in subtypes:
            if data := find(subtype):
                if not sources.get("subtype"):
                    sources["subtype"] = subtype
                break
        if not data:
            print(f">> \"{name}\": nothing selected", file=sys.stderr)
        # for en in data:
        #     print(en["seq_id"], len(en["seq"]))
        return data

    def positions_to_report(self):
        merged_counters = {pos: collections.Counter() for pos in range(max(gr.longest for gr in self.groups))}
        for group in self.groups:
            for pos in range(len(group.counters)):
                merged_counters[pos].update(group.counters[pos])
        return [pos for pos, cnt in merged_counters.items() if len(cnt) > 1]

    def format_summary(self, threshold: float = None):
        positions = self.positions_to_report()
        # print(f">>>> {positions}", file=sys.stderr)
        rows = [["", *(f"{pos + 1:3d}" for pos in positions)]]
        most_frequent = self.groups[0].most_frequent(positions=positions)
        for no, group in enumerate(self.groups):
            rows += group.make_summary(positions=positions, most_frequent=None if no == 0 else most_frequent, threshold=threshold)
        # pprint.pprint(rows, width=300)
        return format_table(rows)

    def format_json(self):
        positions = self.positions_to_report()
        data = {
            "pos1": [(pos0 + 1) for pos0 in positions],
            "groups": [group.format_json(positions) for group in self.groups],
        }
        return json.dumps(data, indent=1)

    def format_html(self):
        return "", ""

# ----------------------------------------------------------------------

def format_table(rows, column_space: int = 2):
    col_width = [0 for col in rows[0]]
    for row in rows:
        for no, col in enumerate(row):
            col_width[no] = max(col_width[no], len(col))
    output = ""
    col_space = " " * column_space
    for row in rows:
        output += f"{row[0]:<{col_width[0]}}"
        for no, col in enumerate(row[1:], start=1):
            output += f"{col_space}{col:^{col_width[no]}}"
        output += "\n"
    return output

# ----------------------------------------------------------------------

sSubtypeFix = {"B": "B", "BVIC": "B", "BV": "B", "BY": "B", "BYAM": "B", "A(H1N1)": "A(H1N1)", "H1": "A(H1N1)", "1": "A(H1N1)", "A(H3N2)": "A(H3N2)", "H3": "A(H3N2)", "3": "A(H3N2)"}

def main(args: argparse.Namespace):
    groups = Groups(sources=args_to_groups(args.seq_id), nuc=args.nuc)
    # pprint.pprint(groups.groups)
    if args.html:
        print(groups.format_json())
        # html, json = groups.format_html()
        # with args.html.open("w") as out:
        #     out.write(html)
        # with args.html.with_suffix(".data.js").open("w") as out:
        #     out.write(json)
    else:
        print(groups.format_summary())

# ----------------------------------------------------------------------

def args_to_groups(args: list):
    subtype = (args and sSubtypeFix.get(args[0].upper())) or None
    if subtype and subtype[0] == "B" and len(subtype) > 1:
        lineage = subtype[1]
    else:
        lineage = None
    groups = {}
    group = "A"
    for name in (args[1:] if subtype else args):
        if name[0] == ":":
            group = name[1:] or chr(ord("A") + len(groups))
        else:
            groups.setdefault(group, []).append(name)
    return {"subtype": subtype, "lineage": lineage, "groups": groups}

# ----------------------------------------------------------------------

try:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--html", type=Path)
    parser.add_argument("--nuc", action="store_true", default=False)
    parser.add_argument("--open", action="store_true", default=False)
    parser.add_argument("seq_id", nargs="+", help="seq-id or :<group> or :")
    args = parser.parse_args()
    exit_code = main(args) or 0
except Exception as err:
    print(f"> {err}\n{traceback.format_exc()}", file=sys.stderr)
    exit_code = 1
exit(exit_code)

# ======================================================================
